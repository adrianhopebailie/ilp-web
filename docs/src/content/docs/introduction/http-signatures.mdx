---
title: HTTP message signatures
---

import { CodeBlock, LinkOut } from '@interledger/docs-design-system'

HTTP message signatures are cryptographic digital signatures used by the Open Payments API to secure the HTTP messages transferred between sender, receiver, and third-party initiating payment systems.

The creation and verification of these digital signatures enables an authorization server to control access to protected resources in the process of orchestrating transactions.

## Purpose

When exchanging HTTP messages, Open Payments-enabled systems verify the following aspects of message security:

- **Authenticity** of the system requesting permissions to access specific resources.
- **Integrity** of some or all of the message fields to guard against the risk of message tampering.

## Understanding HTTP signatures

### Specification

The Open Payments API adheres to the <LinkOut href='https://datatracker.ietf.org/doc/draft-ietf-httpbis-message-signatures/'>HTTP Message Signature specification</LinkOut> which has been drafted by the HTTP Workgroup of the Internet Engineering Task Force (IETF).

{/* prettier-ignore */}
{/* ### Cryptography and keys

:::caution
This section is WIP
::: \*/}

### Signature algorithms

Various digital signature algorithms can be used to generate HTTP message signatures. The Open Payments API implements the **Ed25519** variant of the EdDSA (Edwards-curve Digital Signature Algorithm), an elliptic curve cryptographic algorithm that offers advantages over earlier generations of public key cryptography algorithms.

The benefits of using Ed25519 include:

- Relatively efficient security offered with smaller key sizes. Earlier generation public-key cryptographic algorithms, such as RSA, offer comparable security with notably larger key sizes.
- Good hash function collision resilience.
- Speed and efficiency for signature generation and verification.
- Guarding against the risk of an encryption key downgrade attack.

For more information about the EdDSA and its variants, refer to <LinkOut href='https://datatracker.ietf.org/doc/html/rfc8032'>RFC8032</LinkOut>.

### Message signature creation

The [RFC8032](https://www.rfc-editor.org/rfc/rfc8032) specification permits the use of different components of an HTTP message to generate a uniquely labelled message signature. There can be multiple signatures within each HTTP message, each one generated using a different signature algorithm.

The Open Payments API implements the specification to create a signature, starting with the original HTTP message.  
This is illustrated using HTTP 1.1, for simplicity:

![An HTTP message, before signature](/img/http-sig/1-original_msg.png)

Next in the process, the following are specified:

- Fields of the message header that will be covered when creating the signature.
- Additional signature parameters.
- The signing algorithm.
- An identifier for the signer's public key, which will later be used for signature verification.

![The message components & other signature parameters](/img/http-sig/2-select_rest_of_sig_params.png)

Based on the above, a signature base gets created.

![The signature base](/img/http-sig/3-sig_base.png)

The signature base gets hashed using SHA-256. The resulting digest gets signed with the signer's private key, producing the signature as a byte string. The output signature gets Base64 encoded, producing a signature value that is ready to be added to the header of the original message.

![The signature base](/img/http-sig/4-sig_creation.png)

The output is a signed HTTP message with a header that includes a labelled signature value, with its associated signature input field:

![The signed HTTP message](/img/http-sig/5-signed_msg.png)

{/* prettier-ignore */}
{/* # Use the HTTP signature Lambda function

:::caution
This section is WIP
::: \*/}
